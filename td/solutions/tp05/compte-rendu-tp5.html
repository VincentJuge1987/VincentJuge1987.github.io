<!DOCTYPE html>
<html>
  <head>
    <title>Compte-rendu de TP5</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" type="text/css" href="../tp04/compte-rendu.css">
  </head>
  <body>
    <h1 class="centered">Compte-rendu de TP5</h1>
    <div class="right">
      Vincent Jugé
    </div>
 
    <h2>Exercice 1&nbsp;: Tableaux</h2>
    <ol>
      <li>
        Il semble que l'on affiche les valeurs d'un tableau avec un diagramme en bâtons,
        dont les couleurs sont corrélées aux valeurs du tableau.
      </li>
      <li>
        J'écris le code Javascript <pre>
      const addThree = array =&gt; {
        let result = [];
        for (let i = 0; i &lt; array.length; i++) {
          result.push(array[i] + 3);
        }
        return result;
      };
      graph('graph2', addThree(array));
        </pre>
      </li>
      <li>
        J'écris le code Javascript <pre>
      const applyForEachElement = (array, fun) =&gt; {
        let result = [];
        for (let i = 0; i &lt; array.length; i++) {
          result.push(fun(array[i]));
        }
        return result;
      };
      const addThree2 = array =&gt; applyForEachElement(array, x =&gt; x+3);
      graph('graph3', addThree2(array));
        </pre>
      </li>
      <li>
        J'écris le code Javascript <pre>
      const applyForEachElement2 = (array, fun) =&gt; {
        let result = [];
        array.forEach(v =&gt; result.push(fun(v)));
        return result;
      };
      const addThree3 = array =&gt; applyForEachElement2(array, x =&gt; x+3);
      graph('graph4', addThree3(array));
        </pre>
      </li>
      <li>
        La fonction <tt>map</tt> applique une fonction (donnée en paramètre)
        à tous les éléments du tableau depuis lequel j'appelle <tt>map</tt>,
        et renvoie le tableau obtenu après avoir appliqué cette fonction,
        le tout sans changer le tableau d'origine.
        Ici, on voulait tout simplement appliquer la fonction <tt>x =&gt; x + 3</tt>
        au tableau d'origine. <br> J'écris donc le code Javascript <pre>
      const addThree4 = array =&gt; array.map(x =&gt; x+3);
      graph('graph4', addThree4(array));
        </pre>
      </li>
      <li>
        La méthode <tt>sort</tt> est différente des méthodes <tt>map</tt> et <tt>filter</tt>
        car elle modifie directement le tableau à partir duquel on l'appelle, mais le renvoie
        quand même, alors que les deux autres méthodes se contentent de calculer un nouveau
        tableau qu'elles renvoient ensuite. Je commence donc par dupliquer le tableau donné en argument,
        avant d'en trier la copie. Cela me donne le code Javascript <pre>
      const sortedArray = array =&gt; array.filter(x =&gt; true).sort((a,b) =&gt; a-b);
      graph('graph6', sortedArray(array));   
</pre>
      </li>
      <li>
        J'écris le code Javascript <pre>
      const positiveArray = array =>&gt;array.filter(x =&gt; x &gt;= 0);
      graph('graph7', positiveArray(array));
        </pre>
      </li>
    </ol>
 
    <h2>Exercice 2&nbsp;: MinMax</h2>
    <ol>
      <li>
        Je parcours directement les valeurs de mon tableau, ce qui me donne le code <pre>
      const minmax = array =&gt; {
        let [min,max] = [array[0],array[0]];
        for (let value of array) {
          [min,max] = [Math.min(min,value),Math.max(max,value)];
        }
        return [min,max];
      };
</pre>
      </li>
      <li>
        Je peux directement écrire le code <pre>
      const minmax2 = array =&gt; [Math.min(...array),Math.max(...array)];
</pre>
      même si c'est tout de même un peu brutal et, surtout, chaque appel de fonction entraîne
      un parcours du tableau, ce qui fait deux parcours en tout, au lieu d'un seul comme demandé.
      </li>
      <li>
        Cette fois-ci, j'écris le code <pre>
      const minmax3 = array =&gt; array.reduce(
        ([a,b],c) =&gt; [Math.min(a,c),Math.max(b,c)],
        [array[0],array[0]]
      );
</pre>
      La fonction d'accumulation utilisée dans <tt>reduce</tt>
      utilise un tableau [a,b] comme accumulateur, d'où la forme assez spécifique
      de la fonction d'accumulation anonyme que j'y insère.
      </li>
      <li>
        Pour créer un tel objet, il faut écrire <pre>{min: 3, max: 7}</pre>
        <br>
        En pratique, cette fois-ci, j'écris donc le code<pre>
      const minmax4 = array =&gt; array.reduce(
        (acc,value) =&gt; {return {min: Math.min(acc.min,value),max: Math.max(acc.max,value)};},
        {min: array[0],max: array[0]}
      );
</pre>
        Attention&nbsp;! Ici, écrire le <tt>return</tt> est indispensable, sinon Javascript
        interprète les accolades comme un bloc d'insctructions et non pas comme le dictionnaire
        que l'on souhaite renvoyer, et ça plante&nbsp;!
      </li>
    </ol>
    
    <h2>Exercice 3&nbsp;: Génération aléatoire et calcul rapide</h2>
    <ol>
      <li>
        J'écris, comme demandé, le code suivant&nbsp;:
        <pre>
      const swap = (array,i,j) =&gt; {[array[i],array[j]] = [array[j],array[i]];};
      const randomArray = function(array) {
        for(let i = 0; i &lt; array.length; i++) {
          swap(array,i,i + random(array.length - i));
        }
      };
</pre>
      </li>
      <li>
        Après avoir traité à part le cas de la dernière case, pour éviter les problèmes
        que causerait la parité du nombre de cases du tableau, j'obtiens le code suivant&nbsp;:
        <pre>
      const minmax5 = function(array) {
        let [min,max] = [array[0],array[0]];
        for(let i = 1; i &lt; array.length; i+=2) {
          let [a,b] = [array[i], array[(i == array.length - 1) ? i: i+1]];
          if (a &gt; b) {
            [a,b] = [b,a];
          }
          [min,max] = [Math.min(min,a), Math.max(max,b)];
        }
        return [min,max];
      };
</pre>
      </li>
    </ol>
  </body>
</html>
